<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">#gitfr</title>
  <subtitle type="text">Projet pour la promotion du bien et la destruction du mal</subtitle>

  <updated>2012-01-31T23:57:42Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://www.gitfr.net/blog" />
  <id>http://www.gitfr.net/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://www.gitfr.net/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://www.gitfr.net/blog</uri>
    </author>
    <title type="html"><![CDATA[Comportement par défaut du git push]]></title>
    <link rel="alternate" type="text/html" href="http://www.gitfr.net/blog/2011/12/11/comportement-par-defaut-du-git-push" />
    <id>http://www.gitfr.net/blog/2011/12/11/comportement-par-defaut-du-git-push</id>
    <updated>2011-12-11T23:19:00Z</updated>
    <published>2011-12-11T23:19:00Z</published>
    <category scheme="http://www.gitfr.net/blog" term="git-pull" />
    <category scheme="http://www.gitfr.net/blog" term="git-push" />
    <category scheme="http://www.gitfr.net/blog" term="git" />
    <category scheme="http://www.gitfr.net/blog" term="refspec" />
    <category scheme="http://www.gitfr.net/blog" term="configuration" />
    <summary type="html"><![CDATA[Comportement par défaut du git push]]></summary>
    <content type="html" xml:base="http://www.gitfr.net/blog/2011/12/11/comportement-par-defaut-du-git-push"><![CDATA[<p>Git est hautement configurable, avec des dizaines de variables possibles
dans le fichier de configuration, la longueur de l'aide de l'option config
donnant d'ailleurs quelques vertiges. Au lieu de faire un (très) long billet
sur les différentes possibilités de configuration, je vous propose plutôt
des billets courts sur un thème particulier de la configuration.</p>
<p>Pour ce premier billet, je souhaite aborder le comportement de Git lors d'un
push. Ce qui ont suivis l'atelier Git à Bordeaux ne seront pas étonnés par ce
choix : ayant totalement oublié cette option, je ne comprenais pas que ma
machine ne se comporte pas comme ceux des participants à l'atelier (ma
crédibilité en tant qu'expert Git en a sérieusement pâti :).</p>
<p>Commençons par lire le manuel sur l'option push.default :</p>
<p>Defines the action git push should take if no refspec is given on the command
line, no refspec is configured in the remote, and no refspec is implied by any
of the options given on the command line. Possible values are: </p>
<ul>
<li>nothing - do not push anything.</li>
<li>matching - push all matching branches. All branches having the same name in
both ends are considered to be matching. This is the default.</li>
<li>upstream - push the current branch to its upstream branch.</li>
<li>tracking - deprecated synonym for upstream.</li>
<li>current - push the current branch to a branch of the same name.</li>
</ul>
<p>Comme vous pouvez le constater, si aucun refspec n'est fourni (en ligne de
commande ou par configuration) le comportement par défaut est de pousser
toutes les branches qui existent en local et sur le serveur. Cela veut donc
dire que si vous tapez la commande <code>git push</code>, vous allez mettre à jour sur le
serveur toutes les branches que vous avez modifié en local, ce qui est rarement
souhaitable. Il faudra indiquer le refspec complet <code>git push origin mybranch</code>
pour éviter cela.</p>
<p>C'est pour cette raison que je configure Git avec l'option upstream :</p>
<blockquote>
<p>$ git config --global push.default upstream</p>
</blockquote>
<p>2 avantages immédiats :</p>
<ul>
<li>Il ne pousse que la branche courante.</li>
<li>Il m'oblige à faire un <em>tracking</em>, ce qui est bien utile.</li>
</ul>
<p>Maintenant, si vous tentez de pousser la branche <em>test</em> avec la commande
<code>git push</code> sans tracking préalable, Git vous répond :</p>
<blockquote>
<p>fatal: The current branch test has no upstream branch.
To push the current branch and set the remote as upstream, use</p>
<p>git push --set-upstream origin test</p>
</blockquote>
<p>Suivez le conseil de Git en tapant la commande ci dessus pour suivre votre
la branche distante test sur origin avec votre branche locale test. Vous verrez
immédiatement un changement sur votre shell avec l'information <strong>u=</strong>, qui 
indique que vos deux branches sont synchronisées.</p>
<h2>Rappel sur le tracking</h2>
<p>Le tracking consiste à <em>associer</em> une branche locale et une branche distante
(dite <em>upstream</em> dans la terminologie Git), ce qui informe Git de la branche
distante à utiliser lors d'un <code>git pull</code>. Si vous ne comprenez pas pourquoi
vous n'êtes pas plus souvent confronté à cette notion de tracking, c'est tout
simplement que Git le fait pour vous la plupart du temps :</p>
<ul>
<li>Git suit la branche master lors d'un clone.</li>
<li>Git suit la branche que vous venez de créer si celle ci existe déjà sur le
   serveur </li>
</ul>
<p>C'est donc (la plupart du temps) dans le cas ou créer une nouvelle branche en
locale sans existance préalable sur le serveur que vous devez explicitement
faire cette association.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.gitfr.net/blog</uri>
    </author>
    <title type="html"><![CDATA[Des exemples de fichiers gitignore]]></title>
    <link rel="alternate" type="text/html" href="http://www.gitfr.net/blog/2010/11/10/des-exemples-de-fichiers-gitignore" />
    <id>http://www.gitfr.net/blog/2010/11/10/des-exemples-de-fichiers-gitignore</id>
    <updated>2010-11-10T18:50:00Z</updated>
    <published>2010-11-10T18:50:00Z</published>
    <category scheme="http://www.gitfr.net/blog" term="git" />
    <category scheme="http://www.gitfr.net/blog" term="configuration" />
    <summary type="html"><![CDATA[Des exemples de fichiers gitignore]]></summary>
    <content type="html" xml:base="http://www.gitfr.net/blog/2010/11/10/des-exemples-de-fichiers-gitignore"><![CDATA[<p>Le projet <a href="http://github.com/github/gitignore">gitignore</a>, lancé par <em>GitHub</em>, est une collection de fichiers <strong>gitignore</strong>. Vous trouverez des exemples pour :</p>
<ul>
<li>des langages (<strong>Python</strong>, <strong>Ruby</strong>, <strong>Scala</strong>...)</li>
<li>des frameworks (<strong>Symphony</strong>,  <strong>Rails</strong>...)</li>
<li>des éditeurs (<strong>Vim</strong>, <strong>Emacs</strong>, <strong>Eclipse</strong>...)</li>
<li>des systèmes d'exploitation (<strong>Linux</strong>, <strong>Windows</strong>...)</li>
</ul>
<p><strong>Note</strong> : ces deux dernières catégories se trouvent dans le répertoire <em>Global</em>.</p>
<p>Pour plus d'informations, (re)lisez le billet sur <a href="http://blog.gitfr.net/post/1475460682/eviter-de-commiter-des-fichiers-indesirables">gitignore</a>.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.gitfr.net/blog</uri>
    </author>
    <title type="html"><![CDATA[Améliorer sa productivité avec un beau shell]]></title>
    <link rel="alternate" type="text/html" href="http://www.gitfr.net/blog/2010/11/06/ameliorer-sa-productivite-avec-un-beau-shell" />
    <id>http://www.gitfr.net/blog/2010/11/06/ameliorer-sa-productivite-avec-un-beau-shell</id>
    <updated>2010-11-06T04:15:00Z</updated>
    <published>2010-11-06T04:15:00Z</published>
    <category scheme="http://www.gitfr.net/blog" term="git" />
    <category scheme="http://www.gitfr.net/blog" term="configuration" />
    <summary type="html"><![CDATA[Améliorer sa productivité avec un beau shell]]></summary>
    <content type="html" xml:base="http://www.gitfr.net/blog/2010/11/06/ameliorer-sa-productivite-avec-un-beau-shell"><![CDATA[<p>Git est avant un outil qu'on utilise en <strong>ligne de commande</strong>. Mais par défaut, le shell ne vous indique pas grand chose de la part de Git, en fait rien du tout :). Il faut donc taper des commandes Git pour connaitre l'état de son dépôt. Au minimum :</p>
<ul>
<li><code>git status</code> pour l'état de son <strong>répertoire de travail</strong> et de son <strong>index</strong></li>
<li><code>git branch</code> pour connaitre dans quelle <strong>branche</strong> on se trouve</li>
</ul>
<p>Et accessoirement, il faut connaitre sa <strong>position</strong> par rapport à la branche distante, l'état de votre pile <strong>stash</strong>, etc. Bref, cela fait beaucoup de commandes à taper régulièrement. Il est bien sur possible de le faire, mais cela demande une grande rigueur : il est si facile par exemple de travailler dans la <strong>mauvaise branche</strong>, ou pire de ne pas travailler dans une branche du tout (ce qu'on appelle un <strong>HEAD détaché</strong>).</p>
<p>Une solution simple et élégante est d'afficher en permanence ces informations. Comme cela, plus d'erreur (cela reste possible mais l'étourderie est plus difficile). Cela tombe bien, le <strong>shell</strong> sait trés bien faire ce boulot !</p>
<p>Vous trouverez beaucoup d'exemples sur le Net, mais ils sont souvent trés basiques : généralement, cela se résume à afficher la branche courante sans gérer correctement tous les cas (comme le fameux <strong>HEAD détaché</strong> cité plus haut). J'ai fouillé le Net de long en large, et voici les 2 projets les plus intéressants à mes yeux :</p>
<ul>
<li><a href="http://volnitsky.com/project/git-prompt/">git-prompt</a></li>
<li>et... le fichier de complétion de Git</li>
</ul>
<p>Et oui ! Ce dernier, livré en standard avec Git, sait aussi faire de l'affichage, et il est même trés bon ! Passage en revue de ces deux solutions.</p>
<h2>Git Prompt</h2>
<p>L'avantage est qu'il est, malgré son nom, compatible avec <strong>SVN</strong> et <strong>Hg</strong>.</p>
<p>Ses fonctionnalités :</p>
<ul>
<li>affichage de la branche courante</li>
<li>affichage du SHA1 courant</li>
<li>configuration de l'affichage du chemin (en absolu ou relatif, choix de la taille max)</li>
<li>affichage du l'état du dépôt, de l'index et du répertoire de travail avec un jeu de couleur (voir plus bas)</li>
<li>affichage des fichiers qui modifie le depôt (désactivable)</li>
<li>affichage du statut de sortie de votre commande (il peut bipper sur une erreur)</li>
<li>la configuration (activation des modules, couleurs...) se fait simplement au travers d'un fichier</li>
<li>il modifie les labels (titre des fenêtres) en affichant le chemin complet</li>
</ul>
<p>Un jeu de couleur indique l'état du dépôt ainsi que des fichiers manipulés (entre paranthèse la couleur par défaut) :</p>
<ol>
<li>état initial du dépôt (blanc)</li>
<li>dépôt "propre" (bleu foncé)</li>
<li>présence de contenu modifié mais non ajouté à l'index (rouge foncé)</li>
<li>présence de contenu modifié et ajouté à l'index (vert)</li>
<li>présence de fichier non tracé (bleu clair)</li>
<li>en cours d'une opération (magenta)</li>
<li>commit détaché (rouge clair)</li>
</ol>
<p>Vous avez donc un visuel assez précis de l'état de votre dépôt. Voici un exemple avec la configuration par défaut :</p>
<p><img alt="Exemple de git-prompt par défaut" src="http://media.tumblr.com/tumblr_lbfwhyLINq1qdkaiq.png" /></p>
<p>Vous pouvez voir que :</p>
<ul>
<li>je suis connecté avec le login <em>sdouche</em></li>
<li>ma machine s'appelle <em>fou-hi</em></li>
<li>je suis sur le dépot <em>git</em></li>
<li>je suis sur la branche "master" (simplifiée en <strong>M</strong> car <em>master</em> est une convention, comme <em>trunk</em>)</li>
<li>je suis sur le commit <em>61d8db</em></li>
<li>le statut du dépot est vert, j'ai donc du contenu modifié et ajouté</li>
<li>un fichier <code>test.py</code> qui n'est pas tracé</li>
<li>un fichier <code>new.txt</code> qui est ajouté</li>
</ul>
<p><strong>Remarque</strong> : l'état du dépôt correspond bien évidemment à l'état du ou des fichiers le plus important (un dépôt ne peut être vert si un fichier est rouge par exemple).</p>
<p>Vous avez maintenant une vue bien plus complète de votre dépôt. Vous pouvez aisement imaginer qu'avoir ces informations en <strong>permanence</strong> est un plus indéniable. Allez sur ce <a href="http://volnitsky.com/project/git-prompt/screenshot-prompt-git.png">lien</a> pour voir le shell en action sur plusieurs commandes.</p>
<p>Pour ma part, je n'apprécie pas trop les <em>prompt</em> à rallonge, j'ai donc une configuration bien plus légère :</p>
<ul>
<li>pas d'affichage de mon login ni du nom de ma machine (il affiche si les valeurs ne sont pas celles par défaut, par ex. si je suis root)</li>
<li>un prompt classique (<strong>$</strong> pour un utilisateur et <strong>#</strong> pour root, et non le <strong>&gt;</strong>)</li>
<li>couleurs personnalisées (répertoire en magenta par ex.)</li>
<li>limite de 40 caractères pour l'affichage du chemin</li>
<li>pas d'affichage des fichiers et / ou répertoires impactés</li>
</ul>
<p>Voici une copie d'écran :</p>
<p><img alt="Un exemple avec ma configuration git-prompt" src="http://media.tumblr.com/tumblr_lbfvzvuwcQ1qdkaiq.png" /></p>
<p>Vous constatez qu'il est bien plus simple. Vous pouvez voir la couleur verte sur le M, cela signifie donc que j'ai ajouté du contenu dans mon index. J'apprécie beaucoup la visualisation de l'ensemble des fichiers impactés mais malheureusement assez peu les prompts trop long.</p>
<p>Pour l'installer, c'est trés simple :</p>
<ul>
<li>Allez sur le projet <a href="https://github.com/lvv/git-prompt">Github</a> et récupérer les fichiers <code>git-prompt.sh</code> et <code>git-prompt.conf</code></li>
<li>Mettez le premier quelque part dans votre compte et renommez le second en <code>~/.git-prompt.conf</code></li>
<li>Modifiez votre fichier <code>~/.bashrc</code> avec cette ligne  (remplacez "/path/to" par le répertoire ou vous avez sauvegardé votre fichier) :</li>
</ul>
<blockquote>
<p>[[ $- == <em>i</em> ]]  &amp;&amp; . ~/path/to/git-prompt.sh</p>
</blockquote>
<ul>
<li>Editez le fichier ~/.git-prompt.conf` pour configurer selon vos envies</li>
</ul>
<h2>Git Completion</h2>
<p>Le fichier de complétion possède tout le nécessaire pour afficher des informations sur votre dépôt, il est même bien plus complet sur certains aspects que <em>git-prompt</em>. Mais ne vous attendait pas à l'utiliser pour autre chose que Git. Il faudra donc choisir selon vos besoins.</p>
<p>En échange, il vous offre pas mal de possibilités, il affiche :</p>
<ul>
<li>la branche courante (ou le SHA1 si vous êtes sur un <em>HEAD détaché</em>)</li>
<li>le caractère <strong>%</strong> si un contenu non tracé existe</li>
<li>le caractère <strong>*</strong> si un contenu tracé mais non ajouté existe</li>
<li>le caractère <strong>+</strong> si un contenu ajouté existe</li>
<li>le caractère <strong>$</strong> si vous avez un <strong>stash</strong></li>
<li>le caractère <strong>#</strong> si le dépôt est dans l'état initial</li>
<li>la position courante de votre <strong>branche locale</strong> par rapport à la branche distante</li>
</ul>
<p>Pour ce dernier, vous avez plusieurs modes :</p>
<ul>
<li>
<p>avec le mode auto il affiche :</p>
</li>
<li>
<p>rien s'il n'existe pas de branche <em>upstream</em></p>
</li>
<li><strong>=</strong> si vous les deux branches concordent</li>
<li><strong>&lt;</strong> pour dire vous étes en avance</li>
<li><strong>&gt;</strong> en retard</li>
<li>
<p><strong>&lt;&gt;</strong> pour indiquer une divergeance</p>
</li>
<li>
<p>avec le mode verbose, il affiche le nombre de commits :</p>
</li>
<li>
<p>rien s'il n'existe pas de branche <em>upstream</em></p>
</li>
<li><strong>u=</strong> si vous les deux branches concordent</li>
<li><strong>u+count</strong> si vous étes en avance</li>
<li><strong>u-count</strong> si vous étes en avance</li>
<li><strong>u+count-u-count</strong> pour indiquer une divergeance (nombre de commits dans votre branche et dans la branche upstream)</li>
</ul>
<p>Cela permet de savoir par exemple si vous avez oublié de pusher ou de merger. Trés pratique, voir <strong>indispensable</strong>.</p>
<p><strong>Remarques :</strong></p>
<ul>
<li>Il affiche aussi le décalage avec SVN (mode <strong>git-svn</strong>) s'il trouve un serveur SVN dans la configuration du dépôt</li>
<li>Vous pouvez modifier la configuration du décalage avec <em>upstream</em> pour chaque dépôt avec la variable <code>bash.showUpstream</code></li>
</ul>
<p>Mais ce n'est pas tout ! Il vous indique si vous êtes en cours :</p>
<ul>
<li>d'un <em>rebase</em> intéractif en affichant <strong>|REBASE-i</strong></li>
<li>d'un <em>rebase</em> merge en affichant <strong>|REBASE-m</strong></li>
<li>d'un <em>merge</em> en affichant <strong>|MERGING</strong></li>
<li>d'un <em>bisect</em> en affichant <strong>|BISECTING</strong></li>
</ul>
<p>Bref, c'est pour moi le shell le plus complet qui existe. Le seul défaut est qu'il ne gère pas la couleur, c'est à vous de l'ajouter. Vraiment dommage.</p>
<p>Voici ce que donne (avec une ajout de couleurs) :</p>
<p><img alt="Un exemple avec Git Completion" src="http://media.tumblr.com/tumblr_lbfviwpAfP1qdkaiq.png" /></p>
<p>Vous pouvez voir que je suis en avance d'un commit (u pour <strong>upstream</strong>) et que j'ai du contenu non tracé et du contenu ajouté mais pas commité.</p>
<p>Pour disposer d'une configuration équivalente, ajoutez ces lignes dans votre fichier <code>~/.bashrc</code>:</p>
<blockquote>
<p><code>GIT_PS1_SHOWDIRTYSTATE=1 GIT_PS1_SHOWUNTRACKEDFILES=1 GIT_PS1_SHOWSTASHSTATE=1 GIT_PS1_SHOWUPSTREAM="verbose"</code></p>
<p><code>PS1='[\[\033[1;35m\]\W$(__git_ps1 " \[\033[1;34m\](%s)")\[\033[0m\]]\$ '</code></p>
</blockquote>
<p>Si vous souhaitez garder votre login et le nom de la machine, voici la configuration de base qui remplace la dernière ligne de la configuration précédente :</p>
<blockquote>
<p><code>PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '</code></p>
</blockquote>
<p>Ajouter <code>\u@\h</code> aprés le <strong>[</strong> à ma configuration si vous voulez associer la configuration de base avec mon jeu de couleurs.</p>
<h2>Notes</h2>
<ul>
<li>Les informations Git s'affichent <strong>uniquement</strong> dans le cas ou vous êtes dans un dépôt Git</li>
<li>Pour en savoir plus sur les couleurs du prompt, je vous conseille ce <a href="https://wiki.archlinux.org/index.php/Color_Bash_Prompt">lien</a></li>
<li>pour utiliser <em>Git Completion</em>, il faut bien évidemment que ce dernier soit installé (voir à se sujet un précédent <a href="http://blog.gitfr.net/post/1475820312/taper-plus-vite-avec-la-completion">billet</a>)</li>
</ul>
<h2>Mon shell idéal</h2>
<p>Cela serait une combinaison des 2 :</p>
<ul>
<li>la possibilité de l'utiliser avec Hg, Bzr et Git</li>
<li>affichage de l'état des fichiers sur la 1ere ligne avec un jeu de couleur (à la git-prompt)</li>
<li>affichage sur la deuxième ligne du nom du dépôt (ce que personne ne fait), le chemin courant, l'état du dépôt (à la Git Completion)</li>
<li>affichage du nombre de patchs dans ma pile de Stash</li>
<li>et surtout le <strong>choix</strong> des couleurs pour chaque élement visuel. Imaginez par exemple du rouge pour afficher un décalage avec <em>upstream</em>, du bleu si j'ai du <em>stash</em>, etc</li>
</ul>
<h2>Conclusion</h2>
<p>Avoir en permanence l'état de votre dépôt est un plus <strong>indéniable</strong>, que je vous <strong>encourage fortement</strong> à installer ! Il m'est arrivé plusieurs fois de commiter dans la mauvaise branche, ou d'oublier de pusher. Avec un beau shell, c'est <strong>fini</strong> (enfin, cela arrive beaucoup moins souvent :).</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.gitfr.net/blog</uri>
    </author>
    <title type="html"><![CDATA[Simplifiez vous la vie avec les alias]]></title>
    <link rel="alternate" type="text/html" href="http://www.gitfr.net/blog/2010/11/04/simplifiez-vous-la-vie-avec-les-alias" />
    <id>http://www.gitfr.net/blog/2010/11/04/simplifiez-vous-la-vie-avec-les-alias</id>
    <updated>2010-11-04T03:33:00Z</updated>
    <published>2010-11-04T03:33:00Z</published>
    <category scheme="http://www.gitfr.net/blog" term="git" />
    <category scheme="http://www.gitfr.net/blog" term="configuration" />
    <summary type="html"><![CDATA[Simplifiez vous la vie avec les alias]]></summary>
    <content type="html" xml:base="http://www.gitfr.net/blog/2010/11/04/simplifiez-vous-la-vie-avec-les-alias"><![CDATA[<p>Git est un couteau Suisse, avec beaucoup de sous commandes et d'options. Il n'est pas rare de taper des lignes assez fastidieuses comme celle ci :</p>
<blockquote>
<p><code>$ git log --graph --abbrev-commit --date=relative</code></p>
</blockquote>
<p>Outre le fait qu'il faut retenir par coeur beaucoup de choses (la commande log est à cet égard un bel exemple), cela devient vite <strong>trés</strong> pénible. Les alias sont la justement pour vous simplifier la vie. Par exemple, pour disposer de raccourci des commandes usuelles :</p>
<blockquote>
<p><code>$ git config --global alias.ci commit</code></p>
<p><code>$ git config --global alias.co checkout</code> </p>
<p><code>$ git config --global alias.br branch</code> </p>
<p><code>$ git config --global alias.st status</code> </p>
</blockquote>
<p>Ou pour reprendre le premier exemple de ce billet :</p>
<blockquote>
<p><code>$ git config --global alias.glog 'log --graph --abbrev-commit --date=relative'</code></p>
</blockquote>
<p>Vous pouvez maintenant visualiser vos logs avec la commande <code>git glog</code>. </p>
<p>Ce qui est formidable avec les alias est qu'ils marchent si on mélange alias et commande "normale". Par exemple :</p>
<blockquote>
<p><code>$ git glog --first-parent</code></p>
</blockquote>
<p>Une autre possibilité intéressante est d'appeler une commande <strong>Shell</strong>. Il suffit pour cela de commencer son alias avec <strong>!</strong> (point d'exclamation). Par exemple :</p>
<blockquote>
<p><code>$ git config --global alias.ka "!gitk --all"</code></p>
</blockquote>
<p>La commande <strong>git ka</strong> appelle le programme <code>gitk</code> avec l'option <code>--all</code>.</p>
<p>Je vous conseille d'user et d'abuser des alias pour :</p>
<ul>
<li>simplifier l'utilisation de commandes complexes</li>
<li>disposer d'un environnement à votre main, avec des raccourcis qui vous parlent</li>
</ul>
<p>Pour illuster le deuxieme point, je préfère taper <strong>undo</strong> que <code>git reset --hard</code>. C'est un choix purement personnel. A titre d'exemple, mon fichier contient 36 alias.</p>
<p><strong>Note</strong> : Cerise sur le gateau, la complétion fonctionne aussi avec les alias.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.gitfr.net/blog</uri>
    </author>
    <title type="html"><![CDATA[Taper plus vite avec la complétion]]></title>
    <link rel="alternate" type="text/html" href="http://www.gitfr.net/blog/2010/11/04/taper-plus-vite-avec-la-completion" />
    <id>http://www.gitfr.net/blog/2010/11/04/taper-plus-vite-avec-la-completion</id>
    <updated>2010-11-04T02:37:00Z</updated>
    <published>2010-11-04T02:37:00Z</published>
    <category scheme="http://www.gitfr.net/blog" term="git" />
    <category scheme="http://www.gitfr.net/blog" term="configuration" />
    <summary type="html"><![CDATA[Taper plus vite avec la complétion]]></summary>
    <content type="html" xml:base="http://www.gitfr.net/blog/2010/11/04/taper-plus-vite-avec-la-completion"><![CDATA[<p>Le petit doigt de la main gauche est pour un <strong>Unixien</strong> un doigt important (bon, vous pouvez me rétorquer que <em>tous</em> les doigts sont importants) : c'est celui qu'on utilise pour taper sur la touche <strong>tab</strong>. Cette touche permet sous Unix de faire la <strong>complétion</strong>. Autrement dit, de compléter le nom d'une commande quand on tape le début de celle-ci. Non seulement une commande, mais aussi les sous commandes et options (par ex <code>--exclude</code> de la commande <code>diff</code>).</p>
<p>Comment cela marche t'il avec Git ? Voici quelques exemples :</p>
<blockquote>
<p><code>$ git &lt;TAB&gt;&lt;TAB&gt;</code></p>
</blockquote>
<p>Le shell répond : </p>
<blockquote>
<p><code>add  bundle  commit  gc  rebase ....</code></p>
</blockquote>
<p>En tapant simplement <code>git</code>, la complétion me propose une centaine de sous commandes Git (je ne représente ci dessus que 4 commandes à titre d'exemple). Maintenant si je tape la lettre <em>a</em> :</p>
<blockquote>
<p><code>$ git a&lt;TAB&gt;&lt;TAB&gt;</code></p>
</blockquote>
<p>Le shell répond :</p>
<blockquote>
<p><code>add  aliases  am  amend  annotate  apply  archive</code></p>
</blockquote>
<p>Le shell me propose les commandes qui commencent par la lettre <em>a</em>. Le shell complète uniquement si ce que vous tapez est <strong>sans ambiguité</strong>. Si je reprends l'exemple précédent, si j'avais tapé <em>ad</em>, la complétion aurait donné <em>add</em>.</p>
<p>Mais ce qui est formi-formi-formidable avec la complétion, c'est qu'elle marche aussi sur les options des sous commandes. En reprenant l'exemple de la sous commande add :</p>
<blockquote>
<p><code>$ git add -&lt;TAB&gt;&lt;TAB&gt;</code></p>
</blockquote>
<p>Le shell répond :</p>
<blockquote>
<p><code>--dry-run  --ignore-errors  --intent-to-add  --interactive  --patch  --refresh  --update</code></p>
</blockquote>
<p>Comme vous pouvez le constater, c'est un gain de temps incroyable. Pour la petite histoire, c'est la fréquence d'utilisation de cette touche qui me donne une première idée de la familiarité d'un candidat avec Unix en entretien d'embauche :).</p>
<p><strong>Note</strong> : vous constaterez peut être que toutes les sous commandes ou options ne sont pas représentées dans la complétion. C'est un choix (ou non, par exemple un oubli ?) des développeurs du fichier de complétion. Il faut en effet modifier manuellement ce fichier à chaque nouvelle version (travail un poil fastidieux, pour vous donner une idée le fichier de la version 1.7.3.2 fait 2419 lignes), il se peut donc que les développeurs fassent des choix. Ceci est aussi valide pour les commandes Shell en général.</p>
<h2>Activer la complétion</h2>
<p>C'est assez simple, il suffit d'ajouter le fichier de complétion Git soit dans votre profil (fichier <code>~/.bashrc</code>), soit dans la configuration globale de bash_completion du système. La plupart du temps, cette configuration est automatique à l'installation de Git.</p>
<h2>Sous Ubuntu</h2>
<p>Le fichier de complétion est automatiquement activé sous Ubuntu car le fichier <code>git</code> est placé dans le répertoire <code>/etc/bash_completion.d/</code> par le paquet git lui même. Le paquet <code>bash-completion</code> étant lui installé par défaut.</p>
<h2>Sous Mac OS X</h2>
<p>Il est nécessaire d'installer (avec Homebrew ou MacPorts) le paquet <code>bash_completion</code> si ce n'est pas deja fait, avec la commande :</p>
<blockquote>
<p>$ sudo port install bash_completion</p>
</blockquote>
<p>ou</p>
<blockquote>
<p>$ brew install bash-completion</p>
</blockquote>
<p>Puis d'ajouter cette ligne dans votre <code>~/.bashrc</code>:</p>
<blockquote>
<p><code>source ./path/to/git-completion.bash</code></p>
</blockquote>
<p>Changez <code>/path/to</code> avec le répertoire qui contient le fichier (qui est dofférent selon la méthode d'installation).</p>
<h2>Sous Windows</h2>
<p>Comme sous Ubuntu, la complétion est activé par défaut avec <em>msysgit</em>.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.gitfr.net/blog</uri>
    </author>
    <title type="html"><![CDATA[Eviter de commiter des fichiers indésirables]]></title>
    <link rel="alternate" type="text/html" href="http://www.gitfr.net/blog/2010/11/04/eviter-de-commiter-des-fichiers-indesirables" />
    <id>http://www.gitfr.net/blog/2010/11/04/eviter-de-commiter-des-fichiers-indesirables</id>
    <updated>2010-11-04T02:37:00Z</updated>
    <published>2010-11-04T02:37:00Z</published>
    <category scheme="http://www.gitfr.net/blog" term="git" />
    <category scheme="http://www.gitfr.net/blog" term="configuration" />
    <summary type="html"><![CDATA[Eviter de commiter des fichiers indésirables]]></summary>
    <content type="html" xml:base="http://www.gitfr.net/blog/2010/11/04/eviter-de-commiter-des-fichiers-indesirables"><![CDATA[<p>Pour éviter d'historiser des fichiers qui ne nous intéresse pas, il est nécessaire de configurer le fichier <code>~./gitignore</code>. Bien évidemment, le contenu de ce fichier dépendra fortement du contexte (éditeur utilisé, langage, os...). Personnellement, mon fichier fait 30 lignes, je n'ai donc plus me soucier quand je fais un <code>git add .</code>, et je n'hésite pas à ajouter une exclusion dés que le besoin s'en fait sentir.</p>
<p>La configuration de ce fichier est trés simple :</p>
<ul>
<li>1 ligne par exclusion</li>
<li>si c'est un répertoire, mettre son nom (comme <code>egg</code>)</li>
<li>si c'est un fichier, ajouter un wildcard (comme <code>*.egg</code>)</li>
</ul>
<p>Enfin, il faut modifier sa configuration Git pour utiliser ce filtre d'exclusion sur tous les dépôts avec la ligne <code>excludesfile=/path/to/.gitignore</code> dans la section <code>[core]</code> (remplacer "/path/to" par le chemin vers votre fichier). Ce qui donne :</p>
<blockquote>
<p><code>[core]</code></p>
<p><code>excludesfile=/home/sdouche/.gitignore</code></p>
</blockquote>
<p>Disposer d'un gitignore à deux intérêts :</p>
<ol>
<li>éviter de commiter des fichiers indésirables</li>
<li>ne pas être surchargé d'informations inutiles (présence de fichier <em>non suivis</em>, <strong>untracked</strong> en anglais)</li>
</ol>
<p>Nous allons voir plus tard que c'est pénible quand nous avons un <strong>prompt</strong> qui affiche <strong>en permanence</strong> la présence de ces fameux fichiers indésirables.</p>
<p>Pour plus d'information sur gitignore, je vous conseille la lecture de la <a href="http://www.kernel.org/pub/software/scm/git/docs/gitignore.html">doc</a>.</p>
<p>Note : il est bien sûr possible de disposer d'un fichier <em>gitignore</em> par dépôt, utile quand on veut s'assurer que les développeurs (par exemple sur un projet Libre) ne feront pas la bétise de commiter ces fichiers à cause d'une mauvaise configuration.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.gitfr.net/blog</uri>
    </author>
    <title type="html"><![CDATA[Configuration minimale pour démarrer]]></title>
    <link rel="alternate" type="text/html" href="http://www.gitfr.net/blog/2010/11/04/configuration-minimale-pour-demarrer" />
    <id>http://www.gitfr.net/blog/2010/11/04/configuration-minimale-pour-demarrer</id>
    <updated>2010-11-04T02:01:00Z</updated>
    <published>2010-11-04T02:01:00Z</published>
    <category scheme="http://www.gitfr.net/blog" term="git" />
    <category scheme="http://www.gitfr.net/blog" term="configuration" />
    <summary type="html"><![CDATA[Configuration minimale pour démarrer]]></summary>
    <content type="html" xml:base="http://www.gitfr.net/blog/2010/11/04/configuration-minimale-pour-demarrer"><![CDATA[<p>La configuration minimale se résume à donner son nom et son adresse email (pour indiquer qui est le "propriétaire" du commit) : </p>
<blockquote>
<p><code>$ git config --global user.name "Sebastien Douche"</code></p>
<p><code>$ git config --global user.email sdouche@gmail.com</code></p>
</blockquote>
<p>L'option <code>--global</code> permet de configurer pour tous les dépôts que vous allez utiliser, en enregistrant ces paramètres dans le fichier <code>~/.gitconfig</code>.</p>
<p>Avec l'option <code>--system</code>, c'est une configuration pour tous les utilisateurs de la machine, et la configuration se trouve dans le fichier <code>/etc/gitconfig</code>.</p>
<p>Sans option, vous configurez uniquement le dépôt courant, ce qui permet par exemple de spécifier votre adresse personnelle et non professionnelle.</p>
<p>Trois petites informations supplémentaires :</p>
<ul>
<li>
<p>Sans cette configuration, Git va utiliser directement les informations contenues dans votre profil utilisateur système, ce qui n'est pas souhaité (par ex. <code>seb@mamachine</code>). </p>
</li>
<li>
<p>Il n'y a <strong>pas</strong> de vérification par Git. Ce dernier créé une entrée <em>name</em> dans la section <em>user</em>. Si vous tapez <code>userz.namer</code>, c'est pareil pour lui.</p>
</li>
<li>
<p>Vous pouvez éditer directement les fichiers, le résultat est strictement identique. D'ailleurs je vous conseille d'éditer les fichiers pour voir à quoi ils ressemblent (avant et aprés modification).</p>
</li>
</ul>]]></content>
  </entry>
</feed>
